import { themes, Image } from "mdx-deck";
import modular from "../../assets/modular.png";

export const theme = themes.book;

<Header>

Fundamentos de programaci√≥n con Javascript - Capitulo 3
Modularizaci√≥n y Funciones

</Header>

## Bienvenides a fundamentos de programacion, capitulo 3!

- Diferencias entre const, let y var
- Modularizaci√≥n y funciones

---

## Diferencias entre const, let y var

Antes de empezar a hablar de las diferencias de cada una tenemos que entender que es el √°mbito o scope de una variable.

El scope de una variable se define como el alcance que tiene esta dentro del c√≥digo, es decir, en que puntos del programa una variable puede ser usada y en qu√© puntos no.

---

### Variable con Var

Las declaraciones **var** tienen alcance global y en la funci√≥n alcance local.

El alcance es global cuando una variable¬†`var`¬†se declara fuera de una funci√≥n. Esto significa que cualquier variable que se declare con¬†`var`¬†fuera de un bloque de funciones est√° disponible para su uso en todo el programa.

`var`¬†tiene un alcance de funci√≥n cuando se declara dentro de una funci√≥n. Esto significa que est√° disponible y se puede acceder solo dentro de esa funci√≥n.

---

**Ejemplo**

```jsx
var variable_1 = "Esto es la variable 1";
function imprimir() {
  var variable_2 = "Esto es la variable 2";
}

console.log(variable_2); // error: varibale_2 is not defined
```

`variable_1` tiene un alcance global porque est√° declarada fuera de una funci√≥n, mientras que `variable_2` tiene un alcance de funci√≥n. Por lo tanto, no podemos acceder a la variable `variable_2` fuera de la funci√≥n que pertenece y por eso nos devuelve un error.

---

Las variables declaradas con¬†`var`¬†**se pueden volver a declarar y actualizar,** esto significa que podemos hacer esto dentro del mismo alcance y no obtendremos un error.

```jsx
var variable_1 = "Buenas! Soy la variable 1";

var variable_1 = "Chau! Soy la variable 1";

cosnole.log(variable_1); // Chau! Soy la variable 1
```

---

Que `var` sea de √°mbito global tiene sus desventajas. Lo vemos en el siguiente ejemplo.

```jsx
var variable_1 = "Buenas! Soy la variable 1";
if (true) {
  var variable_1 = "Chau! Soy la variable 1";
}

console.log(variable_1); // "Chau! Soy la variable 1"
```

Cuando dentro del `If` volvemos a declarar y asignarle un valor a `variable_1` pisamos a la primera declaraci√≥n y asignaci√≥n de `variable_1`. Si bien esto no es un problema si somos consientes de lo que esta pasando pero se convierte en un problema cuando no te das cuenta de que ya se ha definido un valor diferente en otra parte del c√≥digo.

Esto puede causar muchos errores en tu c√≥digo. Es por eso que let y const son necesarios.

---

### **Variable con let**

El problema que coment√°bamos que tiene `var` lo soluciona `let`. El alcance de `let` es por bloque, un bloque es todo fragmento de c√≥digo que este entre `{}`.

---

Por lo tanto, una variable declarada en un bloque con `let` solo est√° disponible para su uso dentro de ese bloque. Miremos el ejemplo anterior pero usando `let`.

```jsx
let variable_1 = "Buenas! Soy la variable 1";
if (true) {
  let variable_1 = "Chau! Soy la variable 1";
  console.log(variable_1); // "Chau! Soy la variable 1"
}

console.log(variable_1); // "Buenas! Soy la variable 1"
```

Podemos observar que las declaraciones no se pisan, ya que cada variable vive en su bloque.

---

Si queremos acceder a una variable que existe en un √°mbito diferente de donde fue declarada, nos devuelve un error. Esto se debe a que las variables son de √°mbito de bloque.

```jsx
let variable_1 = "Buenas! Soy la variable 1";
if (true) {
  let variable_2 = "Chau! Soy la variable 1";
  console.log(variable_2); // "Chau! Soy la variable 2"
}

console.log(variable_2); // variable_2 is not defined
```

---

A diferencia de `var`, una variable `let` no se puede volver a declarar dentro de su alcance, entonces si la volvemos a declarar nos va a devolver un error.

```jsx
let variable_2 = "Primera vez";

let variable_2 = "Segunda vez";

// error: Identifier 'variable_2' has already been declared
```

---

### **Variable con const**

Las variables declaradas con `const` tienen el mismo comportamiento que `let` con la diferencia que el valor se tiene que asignar al momento de la declaraci√≥n y no puede cambiar. `const` no se puede actualizar o volver a declarar.

Miremos algunos ejemplos

```jsx
const variable_1 = "Te saludo de nuevo!";

variable_1 = "Me voy";
// error: Assignment to constant variable.
```

---

Esto pasa porque al declararlo con `const` su valor no puede cambiar.

```jsx
const variable_1 = "Te saludo de nuevo!";

const variable_1 = "Me voy";
// error: Identifier 'variable_1' has already been declared
```

---

Visto todo esto, mencionemos las diferencias entre ¬†`var`,¬†`let`¬†y¬†`const`:

- Las declaraciones `var` tienen un alcance global o alcance a una funci√≥n mientras que `let` y `const` tienen un alcance de bloque.
- Las variables `var` se pueden actualizar y volver a declarar dentro de su alcance, mientras que las variables `let` permite que las variables se puedan actualizar, pero no volver a declarar y las variables `const` no se pueden actualizar ni volver a declarar.
- Mientras que `var` y `let` pueden declararse sin inicializarse, const debe inicializarse durante la declaraci√≥n.

---

## Modularizaci√≥n y Funciones

### Modularizaci√≥n

Dividir un problemas en partes mas simples.

Modularizaci√≥n quire decir dividir el programa en partes mas peque√±a dedicadas a hacer un trabajo en especifico, la cual tendr√≠a que trabajar junto al resto del c√≥digo.
Los beneficios que nos da modularizar es no repetir c√≥digo, f√°cil mantenimiento del programa y mejor legibilidad.
La forma de modularizar en javascript es haciendo funciones.

---

<Image
  src={modular}
  style={{
    maxHeight: "600px",
    maxWidth: "750px",
  }}
/>

---

### Funciones

Como hablamos anteriormente b√°sicamente una funci√≥n es un bloque de c√≥digo encargado de una tarea en especifica. Estas funciones pueden recibir valores llamados par√°metros.

---

_"Una funci√≥n en JavaScript es similar a un procedimiento ‚Äî un conjunto de instrucciones que realiza una tarea o calcula un valor, pero para que un procedimiento califique como funci√≥n, debe tomar alguna entrada y devolver una salida donde hay alguna relaci√≥n obvia entre la entrada y la salida. Para usar una funci√≥n, debes definirla en alg√∫n lugar del √°mbito desde el que deseas llamarla."_

Las funciones tambi√©n pueden recibir datos como par√°metros o no, los veremos un poco mas adelante.

---

### Como definir funciones en javascript.

Una definici√≥n de funci√≥n (tambi√©n denominada declaraci√≥n de funci√≥n o expresi√≥n de funci√≥n) consta de la palabra clave function, seguida de:

- El nombre de la funci√≥n.
- Una lista de par√°metros de la funci√≥n, entre par√©ntesis y separados por comas. No necesariamente hay que pasarle par√°metros.
- El bloque de c√≥digo que vas a ejecutar para las funciones en JavaScript que definen entre llaves,¬†`{ ... }`.
- Dentro de la funci√≥n hay que agregar un return, es una palabra clave encargada de devolver "algo", el resultado de la ejecuci√≥n del c√≥digo.

---

**Ejemplo**:

```jsx
function nombre(parametros_1, parametro_2){
//....
	bloque de codigo
...//
return valor_que_vas_a_devolver
}
```

```jsx
function suma(numero_1, numero_2) {
  return numero_1 + numero_2;
}

console.log(suma(2, 3)); //5
```

---

### Hablemos un poco de parametros en JavaScript

Primero vamos a decir que tenemos dos formas de pasar par√°metros en programaci√≥n en general, por valor y por referencia.

- **Por valor**¬†significa que la funci√≥n recibe s√≥lo una copia del valor que tiene la variable, o sea que no la puede modificar.
- **Por referencia**¬†significa que se pasa la posici√≥n de memoria donde esta guardada la variable, por lo que la funci√≥n puede saber cu√°nto vale, pero adem√°s puede modificarla de cualquier manera.

---

Los par√°metros primitivos **(Number, Boolean, String, Undefined)** en JavaScript se pasan por **valor** por eso mismo no podemos modificar esos par√°metros dentro de la funci√≥n para que se vean reflejados fuera.

**Ejemplo por valor:**

```jsx
function nuevoValor(str) {
  str = "nuevo valor";
  return str;
}

const strValor = "Hola mundo";

console.log(nuevoValor(strValor)); // 'nuevo valor'

console.log(strValor); // 'Hola mundo'
```

---

Pero si pasamos un objeto como par√°metro, este s√≠ se va a modificar porque lo hace por referencia, es decir se van a ver reflejados fuera de la funci√≥n.

**Ejemplo por referencia:**

```jsx
function nuevoValor(obj) {
  obj.nuevo = "nuevo";
  return arr;
}

const obj = { valor_1: "valor_1", valor_2: "valor_2" };

nuevoValor(obj);

console.log(obj);
// {valor_1: 'valor_1', valor_2: 'valor_2', nuevo: 'nuevo'}
```

---

Cuando pasamos los par√°metros hay que tomar en cuenta tres casos que se pueden presentar.

- Enviar menos par√°metros de lo que tiene declarado la funci√≥n, a esas variables que no le asignamos un valor javascript no dispara un error, sino que le asigna el valor **"undefined"**.

```jsx
function foo(parametro_1, parametro_2, parametro_3) {
  console.log(parametro_1); // 1
  console.log(parametro_2); // 2
  console.log(parametro_3); // undefined
}

foo(1, 2);
```

---

- Enviar m√°s par√°metros de lo que definimos en la funci√≥n, simplemente los ignora es decir no devuelve un error.

```jsx
function foo(parametro_1, parametro_2, parametro_3) {
  console.log(parametro_1); // 1
  console.log(parametro_2); // 2
  console.log(parametro_3); // 3
}

foo(1, 2, 3, 6);
```

---

- El orden en que mandamos los par√°metros y el que declaramos en la funci√≥n tiene que ser el mismo y no necesariamente se tienen que llamar iguales.

```jsx
function foo(parametro_1, parametro_2, parametro_3) {
  console.log(parametro_1); // 'parametro_1'
  console.log(parametro_2); // 'parametro_3'
  console.log(parametro_3); // ' parametro_2'
}

let parametro_1 = "parametro_1";
let parametro_2 = "parametro_2";
let parametro_3 = "parametro_3";

foo(parametro_1, parametro_3, parametro_2);
```

---

### Llamar a las funciones

Definir una funci√≥n no la ejecuta. Definirla simplemente nombra la funci√≥n y especifica qu√© hacer cuando se llama a la funci√≥n.

B√°sicamente llamar a la funci√≥n consiste en escribir su nombre en donde queramos que se ejecute ese bloque de c√≥digo.

Recordemos la funcion que declaramos anteriormente.

```jsx
suma(5, 2);
```

El c√≥digo anterior llama a la funci√≥n con un argumento de¬†`5` y `2`. La funci√≥n ejecuta sus declaraciones internas y devuelve el valor¬†`7`.

---

Las funciones deben llamarse¬†*dentro del √°mbito*¬†donde fueron declaradas para que se puedan ejecutar.

El √°mbito de una funci√≥n es la funci√≥n en la que se declara (o el programa completo, si se declara en el nivel superior).

```jsx
function padre() {
  console.log("padre");
  function hijo() {
    console.log("hijo");
  }
  hijo(); // "hijo"
}

papa(); // "padre"

// que pasa cuando llamo a la funcion hijo que vive dentro de la funcion padre

hijo(); // => ReferenceError: hijo is not defined
```

---

### **Vamos hacer unos ejercicios con todo lo que vimos üòé**

1. Hacer una funci√≥n que reciba un numero y que retorne verdadero si es par o falso en caso contrario.
2. Hacer una funci√≥n que reciba una serie de palabras separadas por espacios y que imprima la misma frase pero en orden inverso.
3. Hacer una funci√≥n que reciba como par√°metro tres n√∫meros enteros y que lo ordene de mayor a menor.

---

**Soluci√≥n 1**

```jsx
function par(n) {
  if (n % 2 === 0) {
    return true;
  } else {
    return false;
  }
}

console.log(par(5)); //false
```

---

**Soluci√≥n 2**

```jsx
function invertirFrase(n) {
  let frase = "";
  for (let i = n.length - 1; i >= 0; i--) {
    frase += n[i];
  }
  return frase;
}

console.log(invertirFrase("buenas tardes")); //sedrat saneub
```

---

**Soluci√≥n 3**

```jsx
function minNum(num_1, num_2, num_3) {
  let min = 0;
  if (num_1 > num_2) {
    if (num_3 > num_2) {
      min = num_2;
    } else {
      min = num_3;
    }
  } else {
    if (num_3 > num_1) {
      min = num_1;
    } else {
      min = num_3;
    }
  }
  return min;
}
```

---

```jsx
function maxNum(num_1, num_2, num_3) {
  let max = 0;
  if (num_1 < num_2) {
    if (num_3 < num_2) {
      max = num_2;
    } else {
      max = num_3;
    }
  } else {
    if (num_3 < num_1) {
      max = num_1;
    } else {
      max = num_3;
    }
  }
  return max;
}
```

---

```jsx
function ordenar(num_1, num_2, num_3) {
  let max = maxNum(num_1, num_2, num_3);
  let min = minNum(num_1, num_2, num_3);

  let medio = num_1 + num_2 + num_3 - max - min;

  return max + " " + medio + " " + min;
}

console.log(ordenar(33, 77, 36)); // 77 36 33
```
